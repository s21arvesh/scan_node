
name: "Node.js Security Scan"
on:
  workflow_dispatch:
  push:
    branches: [ main, master, develop ]
  pull_request:
    branches: [ main, master, develop ]

jobs:
  node-scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: "18"
        cache: ${{ hashFiles('package-lock.json') != '' && 'npm' || '' }}
        
    - name: Install dependencies
      run: |
        if [ -f "package.json" ]; then
          npm install
        else
          echo "No package.json found, skipping npm install"
        fi
        
    - name: Install scanning tools
      run: |
        npm install -g npm-audit-ci eslint semgrep snyk jshint plato retire
        
    - name: Create report directory
      run: |
        mkdir -p $REPORT_DIR
        
    - name: Run security and quality scans
      run: |
        echo 'Starting Node.js security scan...'
        echo 'Current directory contents:'
        ls -la
        echo 'Looking for package.json:'
        if [ -f "package.json" ]; then
          echo 'package.json found:'
          cat package.json
        else
          echo 'No package.json found - creating dummy one for testing'
          echo '{"name": "test-project", "version": "1.0.0"}' > package.json
        fi
        echo 'Creating ESLint configuration...'
        echo 'module.exports = [];' > eslint.config.js
        echo 'JavaScript files found:'
        find . -name "*.js" -type f | head -10
        echo '=== Running Scan Commands ==='
        echo 'Running ESLint...'
        eslint . --format=json --output-file=$REPORT_DIR/eslint.json || true
        echo 'Running Plato Complexity Analysis...'
        plato -r -d $REPORT_DIR/plato-report . || true
        echo '=== Scan Commands Completed ==='
        echo 'Report directory contents after scans:'
        ls -la $REPORT_DIR/
        
    - name: Generate severity summary
      run: |
        node << 'EOF'
        const fs = require('fs');
        const path = require('path');

        const reportDir = process.env.REPORT_DIR || 'scan-reports';
        let severitySummary = {
            "critical": [],
            "high": [],
            "medium": [],
            "low": [],
            "info": []
        };
        
        console.log('=== DEBUG: Node.js Severity Summary Generation ===');
        console.log('Report directory:', reportDir);
        console.log('Files in report directory:');
        try {
            const files = fs.readdirSync(reportDir);
            console.log(files);
        } catch (e) {
            console.log('Error reading directory:', e);
        }
        
        // Process npm audit results
        console.log('=== DEBUG: Checking npm_audit.json ===');
        if (fs.existsSync(`${reportDir}/npm_audit.json`)) {
            console.log('npm_audit.json found, processing...');
            try {
                const npmData = JSON.parse(fs.readFileSync(`${reportDir}/npm_audit.json`, 'utf8'));
                console.log('npm audit data:', npmData);
                if (npmData.vulnerabilities) {
                    console.log('Found vulnerabilities:', npmData.vulnerabilities.length);
                    npmData.vulnerabilities.forEach(vuln => {
                        const severity = vuln.severity ? vuln.severity.toLowerCase() : 'unknown';
                        if (severitySummary[severity]) {
                            severitySummary[severity].push({
                                'tool': 'npm_audit',
                                'package': vuln.module_name,
                                'version': (vuln.findings && vuln.findings.length > 0) ? vuln.findings[0].version : 'N/A',
                                'issue': vuln.title,
                                'message': vuln.overview || 'Vulnerability found'
                            });
                        }
                    });
                }
            } catch (e) {
                console.log(`Error processing npm_audit.json: ${e}`);
            }
        }
        
        // Process ESLint results
        console.log('=== DEBUG: Checking eslint.json ===');
        if (fs.existsSync(`${reportDir}/eslint.json`)) {
            console.log('eslint.json found, processing...');
            try {
                const eslintData = JSON.parse(fs.readFileSync(`${reportDir}/eslint.json`, 'utf8'));
                console.log('ESLint data:', eslintData);
                console.log('ESLint results count:', eslintData.length);
                eslintData.forEach(result => {
                    // Only add files that have actual issues
                    if (result.errorCount > 0 || result.warningCount > 0) {
                        result.messages.forEach(message => {
                            const severity = message.severity ? (message.severity === 2 ? 'high' : 'medium') : 'medium';
                            if (severitySummary[severity]) {
                                severitySummary[severity].push({
                                    'tool': 'eslint',
                                    'file': result.filePath,
                                    'line': message.line || 'N/A',
                                    'column': message.column || 'N/A',
                                    'issue': message.ruleId || 'eslint-rule',
                                    'message': message.message
                                });
                            }
                        });
                    }
                });
            } catch (e) {
                console.log(`Error processing eslint.json: ${e}`);
            }
        }
        
        // Process Semgrep results
        if (fs.existsSync(`${reportDir}/semgrep.json`)) {
            try {
                const semgrepData = JSON.parse(fs.readFileSync(`${reportDir}/semgrep.json`, 'utf8'));
                semgrepData.results.forEach(result => {
                    const severity = result.metadata.severity ? result.metadata.severity.toLowerCase() : 'medium';
                    if (severitySummary[severity]) {
                        severitySummary[severity].push({
                            'tool': 'semgrep',
                            'file': result.path,
                            'line': result.start ? result.start.line : 'N/A',
                            'issue': result.check_id,
                            'message': result.message
                        });
                    }
                });
            } catch (e) {
                console.log(`Error processing semgrep.json: ${e}`);
            }
        }
        
        // Process Snyk results
        if (fs.existsSync(`${reportDir}/snyk.json`)) {
            try {
                const snykData = JSON.parse(fs.readFileSync(`${reportDir}/snyk.json`, 'utf8'));
                snykData.vulnerabilities.forEach(vuln => {
                    const severity = vuln.severity ? vuln.severity.toLowerCase() : 'medium';
                    if (severitySummary[severity]) {
                        severitySummary[severity].push({
                            'tool': 'snyk',
                            'package': vuln.package,
                            'version': vuln.version,
                            'issue': vuln.title,
                            'message': vuln.description || 'Security vulnerability'
                        });
                    }
                });
            } catch (e) {
                console.log(`Error processing snyk.json: ${e}`);
            }
        }
        
        // Process JSHint results
        if (fs.existsSync(`${reportDir}/jshint.json`)) {
            try {
                const jshintData = JSON.parse(fs.readFileSync(`${reportDir}/jshint.json`, 'utf8'));
                jshintData.forEach(result => {
                    const severity = result.error.code.startsWith('E') ? 'high' : 'medium';
                    if (severitySummary[severity]) {
                        severitySummary[severity].push({
                            'tool': 'jshint',
                            'file': result.file,
                            'line': result.error.line,
                            'issue': result.error.code,
                            'message': result.error.reason
                        });
                    }
                });
            } catch (e) {
                console.log(`Error processing jshint.json: ${e}`);
            }
        }

        // Process Plato results
        if (fs.existsSync(`${reportDir}/plato-report/index.json`)) {
            try {
                const platoData = JSON.parse(fs.readFileSync(`${reportDir}/plato-report/index.json`, 'utf8'));
                Object.keys(platoData.reports).forEach(file => {
                    const report = platoData.reports[file];
                    if (report.complexity && report.complexity.aggregate.complexity.cyclomatic > 10) {
                        severitySummary.medium.push({
                            'tool': 'plato',
                            'file': file,
                            'issue': 'High complexity',
                            'message': `Cyclomatic complexity: ${report.complexity.aggregate.complexity.cyclomatic}`
                        });
                    }
                });
            } catch (e) {
                console.log(`Error processing plato report: ${e}`);
            }
        }

        // Save severity summary
        console.log('=== DEBUG: Final Severity Summary ===');
        console.log('Critical:', severitySummary.critical.length);
        console.log('High:', severitySummary.high.length);
        console.log('Medium:', severitySummary.medium.length);
        console.log('Low:', severitySummary.low.length);
        console.log('Info:', severitySummary.info.length);
        console.log('Final summary:', JSON.stringify(severitySummary, null, 2));
        
        fs.writeFileSync(`${reportDir}/severity_summary.json`, JSON.stringify(severitySummary, null, 2));
        console.log("Node.js severity summary generated successfully");
        EOF
        
    - name: Upload scan reports
      uses: actions/upload-artifact@v4
      if: always()
      with:
        name: node-scan-reports
        path: ${{ env.REPORT_DIR }}/
        retention-days: 30
        
    - name: Generate scan summary
      run: |
        echo "## Node.js Security Scan Results" >> $GITHUB_STEP_SUMMARY
        echo "### Severity Summary" >> $GITHUB_STEP_SUMMARY
        echo '```json' >> $GITHUB_STEP_SUMMARY
        cat $REPORT_DIR/severity_summary.json >> $GITHUB_STEP_SUMMARY
        echo '```' >> $GITHUB_STEP_SUMMARY
        
        echo "### Available Reports" >> $GITHUB_STEP_SUMMARY
        echo "- npm-audit: \`npm_audit.json\`" >> $GITHUB_STEP_SUMMARY
        echo "- ESLint: \`eslint.json\`" >> $GITHUB_STEP_SUMMARY
        echo "- Severity Summary: \`severity_summary.json\`" >> $GITHUB_STEP_SUMMARY
        
        echo "### Repository Information" >> $GITHUB_STEP_SUMMARY
        echo "- Repository: ${{ github.repository }}" >> $GITHUB_STEP_SUMMARY
        echo "- Branch: ${{ github.ref_name }}" >> $GITHUB_STEP_SUMMARY
        echo "- Run ID: ${{ github.run_id }}" >> $GITHUB_STEP_SUMMARY
        
        echo "### Timestamp" >> $GITHUB_STEP_SUMMARY
        echo "- Generated: $(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_STEP_SUMMARY
      shell: bash

env:
  REPORT_DIR: scan-reports
